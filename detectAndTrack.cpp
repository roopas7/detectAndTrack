#include <opencv2/core/utility.hpp>
#include <opencv2/video/background_segm.hpp>
#include <opencv2/objdetect/objdetect.hpp>
#include <opencv2/imgproc/imgproc.hpp>
#include <opencv2/tracking.hpp>
#include <opencv2/videoio.hpp>
#include <opencv2/highgui.hpp>
#include <iostream>
#include <cstring>
#include <vector>
using namespace std;
using namespace cv;
CascadeClassifier cascade;

inline vector<Rect2d> detectObject(Mat frame, Mat frame2, Mat frame3, Mat frame4) 
{
  vector<Rect2d> returnval;
  Mat fgMaskMOG2,fgFinal,fgThresh,fgErode; //fg mask fg mask generated by MOG2 method
  Ptr<BackgroundSubtractor> pMOG2; //MOG2 Background subtractor
  //BackgroundSubtractor* pMOG2; //MOG2 Background subtractor
  pMOG2 = createBackgroundSubtractorMOG2(); //MOG2 approach
  pMOG2->apply(frame, fgMaskMOG2);
  pMOG2->apply(frame2, fgMaskMOG2);
  pMOG2->apply(frame3, fgMaskMOG2);
  pMOG2->apply(frame4, fgMaskMOG2);
  imshow("bg" , fgMaskMOG2);
  imwrite("background.jpg", fgMaskMOG2);
  cv::threshold(fgMaskMOG2,fgMaskMOG2,150,255,2);
  cv::Mat element = getStructuringElement(MORPH_RECT, Size(3, 3), Point(1, 1));
  erode(fgMaskMOG2, fgMaskMOG2, element);
  element = getStructuringElement(MORPH_RECT, Size(15,15), Point(7, 7));
  dilate(fgMaskMOG2, fgFinal, element);
  std::vector< std::vector<cv::Point> > contours;
  std::vector<cv::Point> points;
  imshow("contour", fgFinal);
  findContours(fgFinal, contours, CV_RETR_LIST, CV_CHAIN_APPROX_NONE);
  for (size_t i=0; i<contours.size(); i++) {
      points.clear();
      for (size_t j = 0; j < contours[i].size(); j++) {
          cv::Point p = contours[i][j];
          points.push_back(p);
      }
      if(points.size() > 30){
          cv::Rect2d brect = cv::boundingRect(cv::Mat(points).reshape(2));
          returnval.push_back(brect);
      }
  }
  imwrite("contour.jpg", fgFinal);
  pMOG2->clear();

  return returnval;
}


int main( int argc, char** argv ){
  // show help
  if(argc<2){
    cout<<
      " Usage: tracker <video_name>\n"
      " examples:\n"
      " example_tracking_kcf Bolt/img/%04d.jpg\n"
      " example_tracking_kcf faceocc2.webm\n"
      << endl;
    return 0;
  }
  // declares all required variables
  Rect2d roi;
  Mat frame,frame2, frame3, frame4;
  // create a tracker object
  MultiTracker*  tracker = new MultiTracker("KCF");
  // set input video
  std::string video = argv[1];
  VideoCapture cap(video);
  if (cap.isOpened()) {
cout << "video is open" << endl;
}
  // get bounding box
  vector<Rect2d> detectedObjects;
  cap >> frame;
  cap >> frame2;
  cap >> frame3;
  cap >> frame4;
  cout << "Detecting" << endl;
  detectedObjects = detectObject(frame,frame2, frame3, frame4);
  cout << "Done detecting " << detectedObjects.size() << " objects" << endl;
  //if (detectedObjects.empty()) 
    //return 0;
  // initialize the tracker
  tracker->add(frame,detectedObjects);
  // perform the tracking process
  printf("Start the tracking process, press ESC to quit.\n");
  Scalar colors[3];
  colors[0] = Scalar(255, 0 ,0);
  colors[1] = Scalar(0, 255, 0);
  colors[2] = Scalar(0, 0, 255);
  for (unsigned i = 0; i < detectedObjects.size(); i++)
  {
      rectangle(frame, detectedObjects[i], colors[i%3], 2, 1);
  }
  imwrite("rectangle.jpg", frame);
  //imshow("rectangle", frame);
  VideoWriter writer;
  //int codec = CV_FOURCC('M', 'J', 'P', 'G');  // select desired codec (must be available at runtime)
  int codec = CV_FOURCC('M', 'P', '4', '2');  // select desired codec (must be available at runtime)
  double fps = 25.0;                          // framerate of the created video stream
  string filename = "./live.mp4";             // name of the output video file
  writer.open(filename, codec, fps, frame.size(), true);
  // check if we succeeded
  if (!writer.isOpened()) {
      cerr << "Could not open the output video file for write\n";
      return -1;
  }
  int framesTillLastDetect = 0;
  for ( ;; ){
    framesTillLastDetect++;
    if (0&& framesTillLastDetect > 10) {
      cap >> frame;
      cap >> frame2;
      cap >> frame3;
      cap >> frame4;
      detectedObjects.clear();
      detectedObjects = detectObject(frame,frame2, frame3, frame4);
      cout << "Done detecting " << detectedObjects.size() << " objects" << endl;
      //if (detectedObjects.empty()) 
        //return 0;
      // initialize the tracker
      delete tracker;
      tracker = new MultiTracker("KCF");
      tracker->add(frame4,detectedObjects);
      framesTillLastDetect = 0;
    }
    cap >> frame;
    // stop the program if no more images
    if(frame.rows==0 || frame.cols==0)
      break;
    // update the tracking result
    detectedObjects.clear();
    tracker->update(frame,detectedObjects);
    // draw the tracked object
    for (unsigned i = 0; i < detectedObjects.size(); i++)
    {
        //rectangle(frame, tracker->objects[i], Scalar(255, 0, 0), 2, 1);
       cv::Rect rect(cv::Point(), frame.size());
       cv::Rect rect1(detectedObjects[i]);

       if ((rect1  & rect).area() > 0.8*rect1.area()) {

        rectangle(frame, detectedObjects[i], colors[i%3], 2, 1);
}
    }
			
    // show image with the tracked object
    imshow("tracker",frame);
    writer.write(frame);
    //quit on ESC button
    if(waitKey(1)==27)break;
  }
  return 0;
}

